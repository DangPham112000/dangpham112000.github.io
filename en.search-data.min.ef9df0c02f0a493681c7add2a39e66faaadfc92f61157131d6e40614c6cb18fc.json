[{"id":0,"href":"/docs/problems/knight_dialer/","title":"Knight Dialer","section":"PROBLEMS","content":"\rKnight dialer\r#\rDescription\r#\rThe chess knight has a unique movement, it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an L). The possible movements of chess knight are shown in this diagaram:\nA chess knight can move as indicated in the chess diagram below: We have a chess knight and a phone pad as shown below, the knight can only stand on a numeric cell (i.e. blue cell). Given an integer n, return how many distinct phone numbers of length n we can dial.\nYou are allowed to place the knight on any numeric cell initially\nand then you should perform n - 1 jumps to dial a number of length n. All jumps should be valid knight jumps.\nAs the answer may be very large, return the answer modulo \\(10^9 \u0026#43; 7\\)\rExample 1:\nInput: n = 1\nOutput: 10\nExplanation: We need to dial a number of length 1, so placing the knight over any numeric cell of the 10 cells is sufficient\nExample 2:\nInput: n = 2\nOutput: 20\nExplanation: All the valid number we can dial are [04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94]\nExample 3:\nInput: n = 3131\nOutput: 136006598\nExplanation: Please take care of the mod\nConstraints:\n1 \u0026lt;= n \u0026lt;= 5000 Solution\r#\rHigh level\r#\rCó thể thấy bàn phím điện thoại khá nhỏ Ta có thể tận dụng các giới hạn này để giải quyết bài toán thay vì đâm đầu vào một công thức tổng quát: Ở một vị trí chỉ có thể nhảy đến 1 tập giới hạn các vị trí khác Số cách di chuyển ở mỗi vị trí là hằng số và có thể liệt kê được Low level\r#\rTa nên bắt đầu bằng 1 ví dụ: đẹp nhất là n = 3\nỞ lần đầu thì vị trí là tất cả các nút Ở lần 2 thì cần duyệt qua từ 0 đến 9 vị trí 0 sẽ có thể nhảy đến 4 và vị trí 1 sẽ có thể nhảy đến 8 và \u0026hellip; Ở lần 3 thì ta sẽ duyệt tiếp bên trong vị trí 0 ở lần 2 vị trí 4 sẽ có thể nhảy đến 3, 9 và 0 vị trí 6 sẽ có thể nhảy đến 1, 7 và 0 trong vị trí 1 ở lần 2 8 =\u0026gt; 1, 3 6 =\u0026gt; 1, 7, 0 \u0026hellip; Các kết quả cần tìm\nVới n = 1, return 10 Với n = 2, 0 có thể đến 4 và 6, 1 có thể đến 8 và 6 Với n = 3, 0 có thể đến 3, 9, 0, 1, 7, 0 1 có thể đến 1, 3, 1, 7, 0 Kết quả là tổng sống lượng vị trí có thể đến\nCần tạo 1 mảng chứa các vị trí khả dụng qua mỗi lần lặp n Có thể thấy ta có thể tạo 2 mảng\nMảng số vị trí khả dụng kế tiếp khi ở vị trí i: [[4, 6], [8, 6], []] Có thể thấy để dùng được mảng vị trí khả dụng thì n phải \u0026gt;= 2 Vậy thì thuật toán cần tìm phải bắt đầu ít nhất từ 2 Code\r/** * @param {number} n * @return {number} */ var knightDialer = function (n) { const nextPlaces = [ [4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9], [], [0, 1, 7], [2, 6], [1, 3], [2, 4], ]; if (n === 1) return 10; const validPlaces = JSON.parse(JSON.stringify(nextPlaces)); for (let time = 3; time \u0026lt;= n; time++) { for (let place = 0; place \u0026lt;= 9; place++) { const newPlaces = []; for (let i = 0; i \u0026lt; validPlaces[place].length; i++) { newPlaces.push(...nextPlaces[validPlaces[place][i]]); } validPlaces[place] = newPlaces; } } const totalWays = validPlaces.reduce((acc, currentArray) =\u0026gt; acc + currentArray.length, 0) % (Math.pow(10, 9) + 7); return totalWays; }; Xuất hiện lỗi runtime error: Cụ thể thì là do out of memory\nKhi thử với các test case nhỏ thì dễ thấy hàm của chúng ta work như mong đợi Nhưng khi thử với số lớn thì sẽ xuất hiện lỗi out of memory Giải thuật chưa tối ưu bộ nhớ ? Chọn cấu trúc dữ liệu chưa phù hợp ? Optimize\r#\rLook back\r#\rCùng nhìn lại cách diễn giải ban đầu:\nn = 1: tất cả các nút\n==\u0026gt; [[0], [1], [2], [3], [4], [5], [6], [7], [8], [9]] n = 2: 0 có thể đến 4 và 6 1 có thể đến 8 và 6 2 có thể đến 7 và 9 \u0026hellip;\n==\u0026gt; [[4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9], [], [0, 1, 7], [2, 6], [1, 3], [2, 4]] n = 3: 0 có thể đến 3, 9, 0, 1, 7, 0 1 có thể đến 1, 3, 1, 7, 0 \u0026hellip;\n==\u0026gt; [[3, 9, 0, 1, 7, 0], [1, 3, 1, 7, 0], ...] \u0026hellip; Dễ thấy n càng cao số phần từ trùng lặp lại trong mảng càng cao Với mỗi phần tử trùng ấy ta lại có cùng một công việc cho chúng Kết quả cần tìm lại là đếm số lượng phần tử của từng mảng ==\u0026gt; Nếu có thể áp dụng cấu trúc Dictionary sẽ là một phương pháp tối ưu\nNew way\r#\rCách diễn dãi mới\nn = 1\n==\u0026gt; dic = {0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1}\n==\u0026gt; dic = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n==\u0026gt; Nên chọn array vì key chúng ta cần chỉ là các con số từ 0-\u0026gt;9 n = 2 0 có thể đến 4 và 6 =\u0026gt; newDic[4] += dic[0] và newDic[6] += dic[0] newDic[4] += dic[0] vì giả sử vị trí 0 đang chứa 2 khả năng, thì 2 khả năng đó đều đi đến được 4 Dùng newDic là để trạng thái cũ k bị xáo trộn khi đang duyệt 1 có thể đến 8 và 6 =\u0026gt; newDic[8] += dic[1] và newDic[6] += dic[1] \u0026hellip; Code\r/** * @param {number} n * @return {number} */ var knightDialer = function (n) { const nextPlaces = [ [4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9], [], [0, 1, 7], [2, 6], [1, 3], [2, 4], ]; if (n === 1) return 10; let dic = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]; for (let time = 2; time \u0026lt;= n; time++) { const newDic = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; for (let place = 0; place \u0026lt;= 9; place++) { for (let i = 0; i \u0026lt; nextPlaces[place].length; i++) { newDic[nextPlaces[place][i]] += dic[place] % (Math.pow(10, 9) + 7); } } dic = newDic; } const totalWays = dic.reduce((acc, item) =\u0026gt; acc + item, 0) % (Math.pow(10, 9) + 7); return totalWays; }; Time and space complexity optimize\r#\rCode\rTiêu chí là ít tính toán lại và tận dụng nhiều hơn\r#\r/** * @param {number} n * @return {number} */ var knightDialer = function (n) { const nextPlaces = [ [4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9], [], [0, 1, 7], [2, 6], [1, 3], [2, 4], ]; if (n === 1) return 10; const mod = Math.pow(10, 9) + 7; let dic = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], newDic = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], place, i; for (let time = 2; time \u0026lt;= n; time++) { newDic = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; for (place = 0; place \u0026lt;= 9; place++) { if (place === 5) continue; for (i = 0; i \u0026lt; nextPlaces[place].length; i++) { newDic[nextPlaces[place][i]] += dic[place] % mod; } } dic = newDic; } const totalWays = dic.reduce((acc, item) =\u0026gt; acc + item, 0) % mod; return totalWays; }; Reference\r#\rLeetcode: knight dialer "},{"id":1,"href":"/docs/research/be_protocol/tcp_udp/","title":"TCP - UDP","section":"Backend Protocol","content":"\rTCP - UDP\r#\r"},{"id":2,"href":"/docs/research/be_protocol/tls_ssl/","title":"TLS - SSL","section":"Backend Protocol","content":"\rTLS - SSL\r#\r"},{"id":3,"href":"/docs/research/be_protocol/http/","title":"HTTP","section":"Backend Protocol","content":"\rHTTP\r#\r"},{"id":4,"href":"/docs/research/be_protocol/https/","title":"HTTPS","section":"Backend Protocol","content":"\rHTTPS\r#\r"},{"id":5,"href":"/docs/research/be_protocol/webrtc/","title":"WebRTC","section":"Backend Protocol","content":"\rWebRTC\r#\r"},{"id":6,"href":"/docs/research/be_protocol/websocket/","title":"Websocket","section":"Backend Protocol","content":"\rWebsocket\r#\r"},{"id":7,"href":"/docs/research/be_protocol/grpc/","title":"gRPC","section":"Backend Protocol","content":"\rgRPC\r#\r"},{"id":8,"href":"/docs/research/be_protocol/communication/","title":"Communication","section":"Backend Protocol","content":"\rCommunication\r#\r"},{"id":9,"href":"/docs/research/chrome_architecture/","title":"Chrome Architecture","section":"RESEARCH","content":"\rChrome Architecture\r#\rPrerequisites\r#\rRead process vs thread first if you don\u0026rsquo;t have any process and thread concept in your mind\nBrowser Architecture\r#\rWhen you start an application, a process is created. The program might create thread(s) to help it do work, but that\u0026rsquo;s optional. The Operating System gives the process a \u0026ldquo;slab\u0026rdquo; of memory to work with and all application state is kept in that private memory space. When you close the application, the process also goes away and the Operating System frees up the memory\nA process can ask the Operating System to spin up another process to run different tasks. When this happens, different parts of the memory are allocated for the new process. If two processes need to talk, they can do so by using Inter Process Communication (IPC). Many applications are designed to work this way so that if a worker process get unresponsive, it can be restarted without stopping other processes which are running different parts of the application.\nThere is no standard specification on how one might build a web browser. One browser’s approach may be completely different from another\nChrome uses a separate content process and engine for each website instance, but Firefox reuses processes and engines to limit memory usage\nProcess What it controls? Browser Controls \u0026ldquo;chrome\u0026rdquo; part of the application including address bar, bookmarks, back and forward buttons. Also handles the invisible, privileged parts of a web browser such as network requests and file access Renderer Controls anything inside of the tab where a website is displayed Plugin Controls any plugins used by the website, for example, flash GPU Handles GPU tasks in isolation from other processes. It is separated into different process because GPUs handles requests from multiple apps and draw them in the same surface There are even more processes like the Extension process and utility processes. If you want to see how many processes are running in your Chrome, click the options menu icon more_vert at the top right corner, select More Tools, then select Task Manager. This opens up a window with a list of processes that are currently running and how much CPU/Memory they are using.\nFor the renderer process, multiple processes are created and assigned to each tab. Until very recently, Chrome gave each tab a process when it could; now it tries to give each site its own process, including iframes\nBrowser process\r#\rThread Mission UI Draws buttons and input fields of the browser Network Deals with network stack to receive data from the internet Storage Controls access to the files and more Renderer process\r#\rThe renderer process is responsible for everything that happens inside of a tab\nThread Mission Main The main thread handles most of the code you send to the user Worker Sometimes parts of your JavaScript is handled by worker threads if you use a web worker or a service worker Compositor and Raster Compositor and raster threads are also run inside of a renderer processes to render a page efficiently and smoothly The renderer process\u0026rsquo;s core job is to turn HTML, CSS, and JavaScript into a web page that the user can interact with\nMain thread\r#\rPharse Job Visual Parsing When the renderer process starts to receive HTML data, the main thread begins to parse the text string (HTML) and turn it into a Document Object Model (DOM) Style calculation The main thread parses CSS and determines the computed style for each DOM node. This is information about what kind of style is applied to each element based on CSS selectors Layout The layout is a process to find the geometry of elements. The main thread walks through the DOM and computed styles and creates the layout tree which has information like x y coordinates and bounding box sizes. Layout tree may be similar structure to the DOM tree, but it only contains information related to what\u0026rsquo;s visible on the page Paint The main thread walks the layout tree to create paint records. Paint record is a note of painting process like \u0026ldquo;background first, then text, then rectangle\u0026rdquo; A website usually uses external resources like images, CSS, and JavaScript. Those files need to be loaded from network or cache. The main thread could request them one by one as they find them while parsing to build a DOM, but in order to speed up, \u0026ldquo;preload scanner\u0026rdquo; is run concurrently.\nWhen the HTML parser finds a \u0026lt;script\u0026gt; tag, it pauses the parsing of the HTML document and has to load, parse, and execute the JavaScript code\nWhy? Because JavaScript can change the shape of the document using things like document.write() which changes the entire DOM structure\nThe browser then loads and runs the JavaScript code asynchronously and does not block the parsing. You may also use JavaScript module if that\u0026rsquo;s suitable. \u0026lt;link rel=\u0026quot;preload\u0026quot;\u0026gt; is a way to inform browser that the resource is definitely needed for current navigation and you would like to download as soon as possible. You can read more on this at Resource Prioritization\nJavaScript\r#\rJavaScript, as you may already know, is single threaded, hence you can’t spawn new threads as you like to spread your computation cost over multiple CPU’s core for true-parallel work\nWhen your code is executed it may call the Browser’s APIs to interact with the DOM or schedule some async task. Those async tasks are added to the Event queue or to the prioritized Job queue (if using Promises). As soon as the the Call Stack has finished to process the current tick (is empty), the Event Loop feeds it with a new Tick (which is composed by ONE callback, the FULL job queue, and the POSSIBILITY to call, fully or only some parts, the Render queue)\nCall Stack: it is the place where your code is executed (your functions are loaded and executed, V8 engine in Chrome and NodeJS), it is basically a LIFO stack (last-in-first-out), when it is empty, a.k.a. has completed all the current Tick tasks, it becomes ready to accept the next Tick from the Event Loop Browser APIs: a link between your code and the browser’s internals to schedule tasks, interact with the DOM and more (ex. setTimeout, AJAX, createElement, querySelector, append, click, etc.). In case of callbacks they will add your callback code to the Event queue, instead, in case of a then (promise’s method), your then-code will be added to the Job Queue Event queue: every time you add a callback (ex. via the setTimeout or the AJAX APIs), it is added to this queue Job queue: this queue is reserved for promise’s thens, it is a prioritized queue, its meaning is like ‘execute this code later (= asynchronously), but as soon as possible! (= before the next Event Loop tick)’, and this is why browsers had introduced this new queue to fulfil the Promises specifications Render queue: this is explained in another article Next Tick: it is what will be executed next, basically it’s composed by ONE callback from the Event queue, THE FULL Job queue (this point is important, the current tick will finish only after the Job queue is empty, so you may inadvertently block it from going to the next Tick if you continuously add new jobs to this queue), may re-render (execute the necessary steps in the Render queue to update the screen) Event Loop: it monitors the Call Stack, as soon as it is empty (has finished to process the current tick), the Event Loop feeds it with the next Tick Along the main thread there are many other threads spawned by the browser to do useful stuff:\nParser Thread: parses your code in machine-understandable trees Statistics collector Thread: collects data and statistics to discover insights about your code (the scope is to optimize it runtime) Optimizer Thread: uses the statistics and insights collected by the Statistics collector Thread to make performance optimizations over your code (Caching, Inlining, etc.) Garbage Collector Thread: removes unconnected (no more referenceable from the ROOT node) JavaScript objects to free up memory using a mark-and-sweep algorithm. We don’t know when this will happen and have no control over it. AFAIK the browser uses this thread to track whose objects to remove and do useful stuff, but when it needs to remove them it actually blocks the main thread and uses it. From the Firefox blog Q:”Silly question here, why must garbage collection stop UI events and js execution? Couldn’t the GC just run in a separate thread?”, R:”It can be done, but the garbage collector is looking at the same objects that the JS currently running is touching, so it must be done carefully. That said, the Firefox GC actually does do some work on a separate thread: some types of objects can be thrown away once they are known to be garbage without affecting the main thread.” Rasterizer Thread: rasterize your graphic into frames Etc. Appendix\r#\rInput events\r#\rThe browser process is only aware of where that gesture occurred since content inside of a tab is handled by the renderer process. So the browser process sends the event type (like touchstart) and its coordinates to the renderer process\nRenderer process handles the event appropriately by finding the event target and running event listeners that are attached\nInput event routed through the browser process to the renderer process\nIf no input event listeners are attached to the page, Compositor thread can create a new composite frame completely independent of the main thread. But what if some event listeners were attached to the page? How would the compositor thread find out if the event needs to be handled?\n“Non-fast scrollable region”\r#\rSince running JavaScript is the main thread\u0026rsquo;s job, when a page is composited, the compositor thread marks a region of the page that has event handlers attached as \u0026ldquo;Non-Fast Scrollable Region\u0026rdquo;\nBy having this information, the compositor thread can make sure to send input event to the main thread if the event occurs in that region. If input event comes from outside of this region, then the compositor thread carries on compositing new frame without waiting for the main thread\nReference\r#\rChrome: Inside look at modern web browser (part 1) (2018 Sep 21) Chrome: Inside look at modern web browser (part 2) (2018 Sep 21) Chrome: Inside look at modern web browser (part 3) (2020 Aug 18) Chrome: Inside look at modern web browser (part 4) (2019 Jan 12) Gitconnected: How web browsers use processes and threads (2020 Jul 17) Medium: Javascript main thread dissected (2017 Nov 13) V8: JavaScript modules (2018 Jun 18) "},{"id":10,"href":"/docs/research/process_vs_thread/","title":"Process vs Thread","section":"RESEARCH","content":"\rProcess vs Thread\r#\rProgram\r#\rA Program is an executable file containing a set of instructions and passively stored on disk\nProcess\r#\rA Process means a program is in execution. When a program is loaded into the memory and becomes active, the program becomes a process or processes\nThread\r#\rA Thread is the smallest unit of execution within a process\nProcess vs Thread\r#\rProcess\r#\rThe process requires some essential resources such as registers, program counter, and stack\nEach process has its own memory address space. One process can not corrupt the memory address space of another process. This means that when one process malfunctions, other processes keep running\nThread\r#\rA process has at least one thread. It’s called the main thread. It’s not uncommon for a process to have many threads\nEach thread has its own stack. Earlier we mentioned registers, program counters and stack pointers as being part of a process. It’s more accurate to say that those things belong to a thread\nThreads within a process share a memory address space\rIt’s possible to communicate between threads using that shared memory space However, one misbehaving thread could bring down the entire process\nCode demo\r#\rWhen one process malfunctions, other processes keep running\rNodejs\nconst cluster = require(\u0026#34;cluster\u0026#34;); if (cluster.isMaster) { // Master process logic console.log(\u0026#34;Master process\u0026#34;, process.pid, \u0026#34;is running\u0026#34;); const normalSlave = cluster.fork(); const misbehavingSlave = cluster.fork(); misbehavingSlave.send({ isNormal: false }); normalSlave.send({ isNormal: true }); setInterval(() =\u0026gt; { console.log(\u0026#34;Master process\u0026#34;, process.pid, \u0026#34;is doing some work.\u0026#34;); }, 300); } else { // Slave process logic console.log(\u0026#34;Slave process\u0026#34;, process.pid, \u0026#34;is running\u0026#34;); process.on(\u0026#34;message\u0026#34;, ({ isNormal }) =\u0026gt; { if (isNormal) { setInterval(() =\u0026gt; { console.log(\u0026#34;Slave process\u0026#34;, process.pid, \u0026#34;is doing some work.\u0026#34;); }, 300); } else { setTimeout(() =\u0026gt; { throw new Error(\u0026#34;Slave process \u0026#34; + process.pid + \u0026#34; is corrupted!!!\u0026#34;); }, 2000); } }); } One misbehaving thread could bring down the entire process\rNodejs\nconst { Worker } = require(\u0026#34;worker_threads\u0026#34;); console.log(\u0026#34;Process\u0026#34;, process.pid, \u0026#34;starts\u0026#34;); // Create a misbehaving worker thread const misbehavingWorker = new Worker( ` const { threadId } = require(\u0026#39;worker_threads\u0026#39;); console.log(\u0026#39;Thread\u0026#39;, threadId, \u0026#39;from process\u0026#39;, process.pid, \u0026#39;starts\u0026#39;); // Intentionally cause an unhandled exception setTimeout(() =\u0026gt; { throw new Error(\u0026#39;Thread \u0026#39; + threadId + \u0026#39; is corrupted!!!\u0026#39;); }, 2000); `, { eval: true } ); // Create a normal worker thread const normalWorker = new Worker( ` const { threadId } = require(\u0026#39;worker_threads\u0026#39;); console.log(\u0026#39;Thread\u0026#39;, threadId, \u0026#39;from process\u0026#39;, process.pid, \u0026#39;starts\u0026#39;); // Simulate normal work setInterval(() =\u0026gt; { console.log(\u0026#39;Thread\u0026#39;, threadId, \u0026#39;is doing some work.\u0026#39;); }, 300); `, { eval: true } ); Multithreading and Multiprocessing\r#\rConcurrency and Parallelism\r#\rConcurrency allows multiple tasks to make progress by interleaving their execution, even if they are not executing simultaneously. It is focused on efficient task scheduling and resource utilization\nParallelism involves executing multiple tasks simultaneously, typically on separate processing units or cores. It aims to achieve higher performance and faster task completion\nMultithreading\r#\rMultithreading focuses on generating computing threads from a single process, whereas multiprocessing increases computing power by adding processors\nMultiprocessing\r#\rMultiprocessing uses two or more processors to increase computing power, whereas multithreading uses a single process with multiple code segments to increase computing power\nCode demo\r#\rPrepared files\rNodejs\nk.js\nconst CPUS = require(\u0026#34;os\u0026#34;).cpus(); const NUM_CPU = CPUS.length; const TOTAL_OBJS = 10000000; const numWorkers = NUM_CPU; const workload = TOTAL_OBJS / numWorkers; module.exports = { CPUS, NUM_CPU, TOTAL_OBJS, numWorkers, workload, }; _.js\nconst generateRandomName = () =\u0026gt; { const names = [ \u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Charlie\u0026#34;, \u0026#34;David\u0026#34;, \u0026#34;Eve\u0026#34;, \u0026#34;Frank\u0026#34;, \u0026#34;Grace\u0026#34;, \u0026#34;Henry\u0026#34;, \u0026#34;Ivy\u0026#34;, \u0026#34;Jack\u0026#34;, ]; return names[Math.floor(Math.random() * names.length)]; }; const generateRandomAge = () =\u0026gt; { return Math.floor(Math.random() * 100) + 1; }; const generateObjects = (count) =\u0026gt; { const objects = []; for (let i = 0; i \u0026lt; count; i++) { const object = { name: generateRandomName(), age: generateRandomAge(), createTime: new Date(), }; objects.push(object); } return objects; }; class Logger { constructor(isEnable) { this.isEnable = !!isEnable; } isDebug = false; logP1(...args) { if (this.isEnable) { console.log(...args); } } debug(...args) { if (this.isDebug \u0026amp;\u0026amp; this.isEnable) { console.log(...args); } } } const ts = () =\u0026gt; new Date().getTime(); class Monitor { startTime; endTime; start() { this.startTime = ts(); } end() { this.endTime = ts(); } getTotal() { return this.endTime - this.startTime; } } module.exports = { Logger, Monitor, generateObjects, }; worker.js\nconst { generateObjects, Monitor, Logger } = require(\u0026#34;../_\u0026#34;); const { workerData, parentPort, threadId } = require(\u0026#34;worker_threads\u0026#34;); const monitor = new Monitor(); const logger = new Logger(true); const { workload, isDebug } = workerData; logger.isDebug = isDebug; logger.debug(\u0026#34;Worker\u0026#34;, threadId, \u0026#34;of process\u0026#34;, process.pid, \u0026#34;is running\u0026#34;); monitor.start(); const objects = generateObjects(workload); monitor.end(); logger.debug( \u0026#34;Worker\u0026#34;, threadId, \u0026#34;generated\u0026#34;, objects.length, \u0026#34;in\u0026#34;, monitor.getTotal(), \u0026#34;ms\u0026#34; ); monitor.start(); parentPort.postMessage(objects); monitor.end(); logger.debug(\u0026#34;worker\u0026#34;, threadId, \u0026#34;send data in\u0026#34;, monitor.getTotal(), \u0026#34;ms\u0026#34;); Single thread vs multithreading vs multiprocessing\rNodejs\nsingleThread.js\nconst { TOTAL_OBJS } = require(\u0026#34;../k\u0026#34;); const { generateObjects, Monitor } = require(\u0026#34;../_\u0026#34;); const monitor = new Monitor(); monitor.start(); const obj = generateObjects(TOTAL_OBJS); monitor.end(); console.log(\u0026#34;Generate\u0026#34;, obj.length, \u0026#34;in\u0026#34;, monitor.getTotal(), \u0026#34;ms\u0026#34;); multithread.js\nconst { Worker } = require(\u0026#34;worker_threads\u0026#34;); const { numWorkers, workload, TOTAL_OBJS } = require(\u0026#34;../k\u0026#34;); const { Monitor, Logger } = require(\u0026#34;../_\u0026#34;); let generatedObjects = []; const monitor = new Monitor(); const logger = new Logger(true); // set true to see more logs logger.isDebug = true; function runWorker(workerData) { return new Promise((resolve, reject) =\u0026gt; { const worker = new Worker(\u0026#34;./worker_threads/worker.js\u0026#34;, { workerData }); logger.debug(\u0026#34;Worker\u0026#34;, worker.threadId, \u0026#34;is running\u0026#34;); worker.on(\u0026#34;message\u0026#34;, (message) =\u0026gt; { generatedObjects = generatedObjects.concat(message); }); worker.on(\u0026#34;error\u0026#34;, reject); worker.on(\u0026#34;exit\u0026#34;, (code) =\u0026gt; { if (code === 0) { resolve(); } else { reject(new Error(`Worker stopped with exit code ${code}`)); } }); }); } async function generateObjectsWithWorkers() { const workers = []; monitor.start(); for (let i = 0; i \u0026lt; numWorkers; i++) { const workerData = { workload, isDebug: logger.isDebug, }; workers.push(runWorker(workerData)); } await Promise.all(workers); monitor.end(); logger.logP1( \u0026#34;All done!\u0026#34;, numWorkers, \u0026#34;workers,\u0026#34;, generatedObjects.length, \u0026#34;objects, in\u0026#34;, monitor.getTotal(), \u0026#34;ms\u0026#34; ); } generateObjectsWithWorkers(); multiprocess.js\nconst cluster = require(\u0026#34;cluster\u0026#34;); const { workload, numWorkers } = require(\u0026#34;../k\u0026#34;); const { Monitor, Logger, generateObjects } = require(\u0026#34;../_\u0026#34;); const logger = new Logger(true); const monitor = new Monitor(); // set true to see more logs logger.isDebug = true; if (cluster.isMaster) { monitor.start(); logger.logP1(\u0026#34;Master\u0026#34;, process.pid, \u0026#34;is running\u0026#34;); // Fork slaves for (let i = 0; i \u0026lt; numWorkers; i++) { cluster.fork(); } // Collect data from slaves let generatedObjects = []; cluster.on(\u0026#34;message\u0026#34;, (slave, message) =\u0026gt; { generatedObjects = generatedObjects.concat(message); }); // Wait for all workers to finish logic let slaveOff = 0; cluster.on(\u0026#34;disconnect\u0026#34;, () =\u0026gt; { slaveOff++; if (slaveOff === numWorkers) { monitor.end(); logger.logP1( \u0026#34;All done!\u0026#34;, slaveOff, \u0026#34;slaves, in\u0026#34;, monitor.getTotal(), \u0026#34;ms\u0026#34; ); // Exit the application process.exit(0); } }); } else { // Slave process logic logger.debug(\u0026#34;Slave\u0026#34;, process.pid, \u0026#34;is running\u0026#34;); let generatedObjects = []; // Generate objects in the worker process monitor.start(); const objects = generateObjects(workload); monitor.end(); generatedObjects = generatedObjects.concat(objects); logger.debug( \u0026#34;Generated\u0026#34;, objects.length, \u0026#34;objects in slave\u0026#34;, process.pid, \u0026#34;in\u0026#34;, monitor.getTotal(), \u0026#34;ms\u0026#34; ); // Send objects to the master process monitor.start(); process.send(objects); monitor.end(); logger.debug(\u0026#34;slave\u0026#34;, process.pid, \u0026#34;send data in\u0026#34;, monitor.getTotal(), \u0026#34;ms\u0026#34;); // Disconnect the slave process cluster.worker.disconnect(); } Time-consuming when not communication together\rTime-consuming when running multiple threads and multiple processes without communication together meaning each item runs separately and does not share data\nNodejs\n// TODO: update guideline how it work and how it look (htop) Time-consuming when communication together\rTime-consuming when running multiple threads and multiple processes within communication together meaning each item runs separately but shares data with the main item\nNodejs\n// TODO: update guideline how it work and how it look (htop)\nContext switching\r#\rHow does the OS run threads or processes on a CPU (processor) ? =\u0026gt; This is handled by context switching\rDuring a context switch, one process is switched out of the CPU (processor) so another process can run\nThe OS stores the states of the current running process so the process can be restored and resume execution at a later point\nIt then restores the previously saved states of a different process and resumes execution for that process\nContext switching is expensive. It involves saving and loading registers, switching out memory pages, and updating various kernel data structures\nSwitching execution between threads also requires context switching\nIt’s generally faster to switch context between threads than between processes\nThere are fewer states to track, and more importantly, since threads share the same memory address space, there is no need to switch out virtual memory pages which is one of the most expensive operations during a context switch\nContext switching is so costly, there are other mechanisms to try to minimize it. Some examples are fibers and coroutines\nThese mechanisms trade complexity for even lower context-switching costs\nIn general, they are cooperatively scheduled, that is, they must yield control for others to run\nIn other words, the application itself handles task scheduling\nIt’s the responsibility of the application to make sure a long-running task is broken up by yielding periodically\nConclusion\r#\rProgram, process, and thread:\nThe program contains a set of instructions The program is loaded into memory. It becomes one or more running processes. When a process starts, it is assigned memory and resources The thread is the smallest unit of execution within a process. A process can have one or more threads If we can ideally run each thread on each idle core, we can actually run parallelism all jobs we want with the shortest time consuming\nThe cost when sharing data between threads and processes is also expensive, processes are more expensive than threads because threads inside the process use together shared memory address space\nContext-switching will appear when the scheduler of OS assigns one logical processor more than one thread or process that needs to run. Context-switching is expensive\nAppendix\r#\rProcessor definition\r#\rThere are 2 definitions of the term Processor that can lead you to confusion when researching\nLet’s devine it into 2 names:\nPhysical processor: means processor definition in the hardware world Logical processor: means processor definition in the software world Physical processor\r#\rA processor in this context means the entire CPU chip as the Intel define\nThis image is the complexity of a modern multi-processor, multi-core system Logical processor\r#\rA processor in this context means a virtual core:\nCPU has 8 cores CPU has hyperthreading and it is enabled so each core split into 2 virtual cores Virtual memory\r#\rA computer can address more memory than the amount physically installed on the system. This extra memory is actually called virtual memory and it is a section of a hard disk that\u0026rsquo;s set up to emulate the computer\u0026rsquo;s RAM\nHyper-threading\r#\rIntel® Hyper-Threading Technology is a hardware innovation that allows more than one thread to run on each core. More threads means more work can be done in parallel\nHow does Hyper-Threading work? When Intel® Hyper-Threading Technology is active, the CPU exposes two execution contexts per physical core. This means that one physical core now works like two “logical cores” that can handle different software threads\nReference\r#\rBytebytego: Interview question: Design Twitter (Episode 5) Bytebytego: FANG Interview Question | Process vs Thread Intel: A Better Way to Measure CPU Utilization Medium: Achieving concurrency in Go Stackoverflow: What are the differences between multi-CPU, multi-core and hyper-thread? Tutorialspoint: Operating System - Virtual Memory Wikipedia: Virtual memory Intel: What Is Hyper-Threading? Geeksforgeeks: Difference between User Level thread and Kernel Level thread Geeksforgeeks: Difference between MultiCore and MultiProcessor System Indeed: Multithreading vs. Multiprocessing: What\u0026rsquo;s the Difference? Scaler: Difference Between Multicore and Multiprocessor System Superuser: What\u0026rsquo;s the difference between a multiprocessor and a multiprocessing system? Superuser: What\u0026rsquo;s the difference between multicore proccesor and multiproccess system? Give a thank to ChatGPT dude to support me during a process create multiple supreme demos "},{"id":11,"href":"/docs/research/aws_overview/","title":"AWS Overview","section":"RESEARCH","content":"\rAWS Overview\r#\rSlide\r#\rEC2\r#\rOn-Demand Instances – short workload, predictable pricing, pay by second Has the highest cost Recommended for short-term and un-interrupted workloads, where you can\u0026rsquo;t predict how the application will behave Reserved (1 \u0026amp; 3 years) Reserved Instances – long workloads Recommended for steady-state usage applications (think database) Convertible Reserved Instances – long workloads with flexible instances Savings Plans (1 \u0026amp; 3 years) – commitment to an amount of usage, long workload Spot Instances – short workloads, cheap, can lose instances (less reliable) The MOST cost-efficient Dedicated Hosts – book an entire physical server, control instance placement The most expensive option Dedicated Instances – no other customers will share your hardware No control over instance placement Capacity Reservations – reserve capacity in a specific AZ for any duration Monitoring\r#\rCloudWatch: Metrics: monitor the performance of AWS services and billing metrics Alarms: automate notification, perform EC2 action, notify to SNS based on metric Logs: collect log files from EC2 instances, servers, Lambda functions… Events (or EventBridge): react to events in AWS, or trigger a rule on a schedule CloudTrail: audit API calls made within your AWS account CloudTrail Insights: automated analysis of your CloudTrail Events X-Ray: trace requests made through your distributed applications AWS Health Dashboard: status of all AWS services across all regions AWS Account Health Dashboard: AWS events that impact your infrastructure Amazon CodeGuru: automated code reviews and application performance recommendations "},{"id":12,"href":"/docs/research/be_protocol/","title":"Backend Protocol","section":"RESEARCH","content":"\rBackend Protocol\r#\rWhat is a protocol?\r#\rA system that allows two parties to communicate A protocol is designed with a set of properties Depending on the purpose of the protocol TCP, UDP, HTTP, gRPC, FTP The application protocols (HTTP/1.1, HTTP/2, HTTP/3) run on top of transport protocols (TCP, UDP) Protocol properties\r#\rData format Text based (plain text, JSON, XML) Binary (protobuf, RESP, h2, h3) Transfer mode Message based (UDP, HTTaP) Stream (TCP, WebRTC) Addressing system DNS name, IP, MAC Directionality Bidirectional (TCP) Unidirectional (HTTP) Full/Half duplex State Stateful (TCP, gRPC, apache thrift) Stateless (UDP, HTTP) Routing Proxies, Gateways Flow \u0026amp; Congestion control TCP (Flow \u0026amp; Congestion) UDP (No control) Error management Error code Retries and timeouts Why do we need a communication model?\r#\rAgnostic applications App doesn’t need to to know network medium Otherwise we need an App for WIFI, ethernet vs LTE vs fiber Network Equipment Management Without a standard model, upgrading network equipments becomes difficult Decoupled Innovation Innovations can be done in each layer separately without affecting the rest of the models OSI Model\r#\r7 Layers each describe a specific networking component\nLayer 7 - Application - HTTP/FTP/gRPC\nLayer 6 - Presentation - Encoding, Serialization\nLayer 5 - Session - Connection establishment, TLS\nLayer 4 - Transport - UDP/TCP\nLayer 3 - Network - IP\nLayer 2 - Data link - Frames, Mac address Ethernet\nLayer 1 - Physical - Electric signals, fiber or radio waves\nTCP/IP Model\r#\rMuch simpler than OSI just 4 layers\nApplication (Layer 5, 6 and 7) Transport (Layer 4) Internet (Layer 3) Data link (Layer 2) Physical layer is not officially covered in the model "},{"id":13,"href":"/docs/research/encryption/","title":"Encryption","section":"RESEARCH","content":"\rEncryption\r#\r"},{"id":14,"href":"/docs/tips/git/","title":"Git","section":"TIPS","content":"\rGIT TIPS\r#\rTerminology\r#\rHEAD: your current local working branch origin: the address to your remote git, represent for remote repo tracked file: the file git already had before, so when you edit it, git know this file is modified (M files)\nuntracked, new file: the file recently add and git don’t know anything about it (U files)\nCommit\r#\rgit add . git commit -m \u0026#34;commit message\u0026#34; These 2 commands can combie into 1\ngit commit -am \u0026#34;commit message\u0026#34; Note: this only work with tracked files\nChange previous commit message\r#\rCommit amend\r#\rgit commit --amend -m \u0026#34;new message to replace the previous message\u0026#34; Note: this amend can also simplify by amen :))))\nRebase reword\r#\rgit rebase -i HEAD~1 Vim IDE appear and show a latest commit\rtype i to begin insert mode, ready to modify change pick to r or reword → means you will change this commit message press ESC key to end insert mode type :wq to save new Vim IDE appear to let you change the commit message change and save like the early steps git push -f Opps! Code on wrong branch\r#\rStash\r#\rgit stash git checkout correct-branch git stash pop Note: git stash will only bring the changes on tracked files to store but don\u0026rsquo;t worry when checkout to other branch, the untracked files will move to there also\nOpps! Commit into local main branch\r#\rReset\r#\rSolution 1: Erase the current commit and go back to the earlier commit\ngit reset --hard HEAD~1 Solution 2: Bring the current commit to staged change and go back to the earlier commit\ngit reset --soft HEAD~1 Update the outdated feature branch\r#\rRelocate branch: rebase\r#\rbefore rebase\n==\u0026gt; after rebase\ngit checkout master git pull git rebase master topic git push -f Note: topic branch will have code from F and G of main branch, but if it conflicts with topic branch, the solution will be the same here\nPull origin\r#\rCollect code from master to feature branch. Feature branch in this example is topic branch\ngit checkout master git pull git checkout topic git pull origin master Note: never ever tried it yet\rClean up messy commits\r#\rAccumulate commits: rebase fixup\r#\rIf you have 3 messy commits per 4 commits on your feature branch\ngit rebase -i HEAD~4 Vim IDE appear and show 4 latest commits\rType i to change into insert mode Change pick to f or fixup → means you accumulate this 3 commits Out insert mode with ESC key Type :wq to save\ngit push -f before after Note: the present commit will have all changes from 3 previous commits\nDelete all local branches except main branch\r#\rgit branch | grep -v \u0026#34;main\u0026#34; | xargs git branch -D Explain:\nGet all branches (except for the main) via git branch | grep -v \u0026quot;main\u0026quot; command Select every branch with xargs command Delete branch with git branch -D Refresh outdated local branch\r#\rIf you pull but show some warnings or errors and git show a recommend that is need to type some rebase commands Just checkout to another branch, delete your local conflict branch and then checkout to this branch again to download a latest one in remote repo git checkout dev git branch -D feature-branch git fetch git checkout feature-branch Force pull\r#\rgit pull -f Note: never ever tried it yet\rMerge PR but get stuck in conflict\r#\rRelocate branch: rebase\r#\rgit checkout main git pull checkout feature-branch git rebase main feature-branch Conflict appears in IDE\n→ Resolve conflict and save file\rgit add . git rebase --continue Vim IDE appear to make you confirm change\n→ :wq\rgit push -f Log pretty\r#\rgit log --graph --decorate --oneline or\ngit log --graph --decorate Config\r#\rShow current global credential\r#\rgit config --global --list Configure local repo’s credential\r#\rwhen you want it’s different with the global one\ngit config user.name DangPham112000 git config user.email dangpham112000@gmail.com Switch git user tool\r#\rhttps://github.com/geongeorge/Git-User-Switch\n"},{"id":15,"href":"/docs/research/security/","title":"Security","section":"RESEARCH","content":"\rSecurity\r#\rDDOS\r#\rBackdoor attack\r#\rSQL injection\r#\rCross-site scripting (XSS) attack\r#\rCross-site request forgery (CSRF) attack\r#\rCross-domain access attack\r#\rSyn flood attack\r#\rRelay attack\r#\rMan in the middle attack\r#\rrequest modify\r#\rresponse modify\r#\r"},{"id":16,"href":"/docs/tips/unit_test/","title":"Unit Test","section":"TIPS","content":"\rUnit Test\r#\rReset all global variables for each unit test case\r#\rWhat environment the unit test cases are running on: Browser or Nodejs?\r#\rBecause Nodejs does not have browser APIs Sinon stub\r#\rStub a function that is called by another function in the same module\r#\rUsing this.[func_name] when calling it in your module\nStub an export default function\r#\rimport * as query from \u0026#34;/database/query\u0026#34;; const makeQueryStub = sandbox.stub(query, \u0026#34;default\u0026#34;).resolves([]); Work only when running alone\r#\rScenario: A unit test case only pass when running alone but fail when running with other test cases\rCheck:\nRestore all mocks after mocking functions: sandbox.restore() or jest.restoreAllMocks() at afterEach Reset global variables inner module: create a reset function to reset all variable of module to the initial value Mocha - Chai - Sinon sample\r#\rimport sinon from \u0026#34;sinon\u0026#34;; import { function_name, callback_function_name } from \u0026#34;../module_name.js\u0026#34;; const sandbox = sinon.createSandbox(); describe(\u0026#34;module_name\u0026#34;, function () { afterEach(function () { sandbox.restore(); }); describe(\u0026#34;function_name\u0026#34;, function () { it(\u0026#34;Should be a function\u0026#34;, function () { expect(function_name).to.be.a(\u0026#34;function\u0026#34;); }); it(\u0026#34;Should return this value if window.screen is undefined\u0026#34;, function () { sandbox.stub(window, \u0026#34;screen\u0026#34;).value(undefined); expect(function_name()).equal(\u0026#34;expected string\u0026#34;); }); it(\u0026#34;should return expected object when running callback function\u0026#34;, function (done) { callback_function_name(function (returnedData) { expect(returnedData).to.deep.equal({ name: \u0026#34;expected object\u0026#34; }); done(); }); }); }); }); Jest - Sinon sample\r#\rimport sinon from \u0026#34;sinon\u0026#34;; import { function_name, async_function_name } from \u0026#34;../module_name.js\u0026#34;; const sandbox = sinon.createSandbox(); describe(\u0026#34;module_name\u0026#34;, function () { afterEach(function () { sandbox.restore(); }); describe(\u0026#34;function_name\u0026#34;, function () { it(\u0026#34;Should be a function\u0026#34;, function () { expect(typeof function_name).toEqual(\u0026#34;function\u0026#34;); }); it(\u0026#34;Should return this value if window.screen is undefined\u0026#34;, function () { sandbox.stub(window, \u0026#34;screen\u0026#34;).value(undefined); expect(function_name()).toEqual(\u0026#34;expected string\u0026#34;); }); it(\u0026#34;should return expected object when handling function asynchronously\u0026#34;, async () =\u0026gt; { const returnedData = await async_function_name(); expect(returnedData).toEqual({ name: \u0026#34;expected object\u0026#34; }); }); }); }); "},{"id":17,"href":"/books/test3/","title":"Test3","section":"Books","content":"\r4th Level of Menu\r#\rCaesorum illa tu sentit micat vestes papyriferi\r#\rInde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"}]